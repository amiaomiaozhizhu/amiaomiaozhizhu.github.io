<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LC 131 分割回文串</title>
      <link href="/2023/12/leetcode/LC%20131%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2023/12/leetcode/LC%20131%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LC-131-分割回文串"><a href="#LC-131-分割回文串" class="headerlink" title="LC 131 分割回文串"></a>LC 131 分割回文串</h2><p>这是leetcode上的<a href="https://leetcode.cn/problems/palindrome-partitioning/description/"> 131分割回文串 </a>，这是一道中等题</p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><hr><p>枚举相邻两个字母之间要不要分割</p><p><img src="https://ammzz-1309932079.cos.ap-nanjing.myqcloud.com/typora_images202312011451314.png" alt="image.png"></p><p>枚举第一个逗号的位置（或者没有）</p><p>枚举第二个逗号的位置（或者没有）</p><p>回溯三问：</p><ol><li>当前操作？选择回文串 s[i, j], 加入path</li><li>子问题？从下标 &gt; i 的后缀中构造回文分割串</li><li>下一个子问题？从下标 &gt;&#x3D; j + 1 的后缀中构造回文分割</li></ol><p>dfs(i) -&gt; dfs(i + 1) &#x2F; dfs(i + 2) &#x2F; dfs(i + 3)</p><hr><p>python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                t = s[i: j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> t == t[::-<span class="number">1</span>]:</span><br><span class="line">                    path.append(t)</span><br><span class="line">                    dfs(j + <span class="number">1</span>)</span><br><span class="line">                    path.pop()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans  </span><br></pre></td></tr></table></figure><p><font size = 5>t &#x3D;&#x3D; t[ : : -1]判断回文</font></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC 17 电话号码的数字组合</title>
      <link href="/2023/12/leetcode/LC%2017%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/"/>
      <url>/2023/12/leetcode/LC%2017%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LC-17-电话号码的数字组合"><a href="#LC-17-电话号码的数字组合" class="headerlink" title="LC 17 电话号码的数字组合"></a>LC 17 电话号码的数字组合</h2><p>这是leetcode上的<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/"> 17.电话号码的字母组合 </a>，难度为中等</p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://ammzz-1309932079.cos.ap-nanjing.myqcloud.com/typora_images202312011025517.png" alt="image.png"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><hr><p>用一个path保存路径</p><p>回溯三问：</p><ol><li>当前操作？枚举path[i]要填入的字母</li><li>子问题？构造字符串&gt;&#x3D; i的部分</li><li>下一个子问题？构造字符串&gt;&#x3D;i + 1的部分</li></ol><p>dfs(i) -&gt; dfs(i + 1)</p><hr><p>Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MAPPING = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(digits)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        path = [<span class="string">&quot;&quot;</span>] * n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(<span class="string">&quot;&quot;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> MAPPING[<span class="built_in">int</span>(digits[i])]:</span><br><span class="line">                path[i] = c</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">      </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC 784 字母大小写全排列</title>
      <link href="/2023/12/leetcode/LC%20784%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2023/12/leetcode/LC%20784%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="LC-784-字母大小写全排列"><a href="#LC-784-字母大小写全排列" class="headerlink" title="LC 784 字母大小写全排列"></a>LC 784 字母大小写全排列</h2><p>这是leetcode上的<a href="https://leetcode.cn/problems/letter-case-permutation/description/">784字母大小写全排列</a>，难度为<strong>中等</strong></p><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a1b2&quot;</span><br><span class="line">输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;3z4&quot;</span><br><span class="line">输出: [&quot;3z4&quot;,&quot;3Z4&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 12</code></li><li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li></ul><hr><p>站在输入角度：</p><p>空的path构造答案，每次选一个填入</p><p>当前操作？path的这个位置填入一个</p><p>子问题？从 &gt;&#x3D; i 的字符串中确定答案</p><p>下一个子问题？从 &gt;&#x3D; i + 1 的字符串中确定答案</p><p>站在答案角度：</p><p>当前操作？确定[i, j] 的答案</p><p>子问题？从下标 &gt;&#x3D; i 的后缀中确定一段为最终答案</p><p>下一个子问题？ 从下标 &gt;&#x3D; j + 1 中确定下一段为最终答案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;python字符确定</span></span><br><span class="line"><span class="string">字符串.isalnum() : 判断是否是数字字母的组合，如果包含空格返回False。</span></span><br><span class="line"><span class="string">字符串.isalpha() :  判断是否是字母，不区分大小写</span></span><br><span class="line"><span class="string">字符串.isdigit() : 判断是否是数字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">字符串.isupper() : 判断是否全部为大写字母</span></span><br><span class="line"><span class="string">字符串.islower() : 判断是否全部为小写字母</span></span><br><span class="line"><span class="string">字符串.istitle() : 判断除首字母外全部都是小写</span></span><br><span class="line"><span class="string">字符串.lower(): 转为小写字母</span></span><br><span class="line"><span class="string">字符串.upper(): 转为大写字母</span></span><br><span class="line"><span class="string">字符串.swapcase(): 大写转小写，小写转大写</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>python代码：</p><p>从输入角度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCasePermutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = []</span><br><span class="line">        path = [<span class="string">&quot;&quot;</span>] * n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(<span class="string">&quot;&quot;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="string">&quot;直接选择&quot;</span></span><br><span class="line">            path[i] = s[i]</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="string">&quot;转换一下选择&quot;</span></span><br><span class="line">            <span class="keyword">if</span> s[i].isupper():</span><br><span class="line">                path[i] = s[i].lower()</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> s[i].islower():</span><br><span class="line">                path[i] = s[i].upper()</span><br><span class="line">                dfs(i + <span class="number">1</span>)   </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>从答案角度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCasePermutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = []</span><br><span class="line">        path = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            ans.append(<span class="string">&quot;&quot;</span>.join(path))</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="string">&quot;遍历答案将每个变或者不变&quot;</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> path[j].isalpha():</span><br><span class="line">                    path[j] = path[j].swapcase()</span><br><span class="line">                    dfs(j + <span class="number">1</span>)</span><br><span class="line">                    path[j] = path[j].swapcase()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC 78 子集</title>
      <link href="/2023/12/leetcode/LC%2078%20%E5%AD%90%E9%9B%86/"/>
      <url>/2023/12/leetcode/LC%2078%20%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LC-78-子集"><a href="#LC-78-子集" class="headerlink" title="LC 78 子集"></a>LC 78 子集</h2><p>这是leetcode上的<a href="https://leetcode.cn/problems/subsets/description/"> 78子集 </a>，难度为中等</p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><hr><p>子集型回溯</p><p>站在输入角度</p><p><img src="https://ammzz-1309932079.cos.ap-nanjing.myqcloud.com/typora_images202312011036997.png"></p><p>每个元素都可以选&#x2F;不选        </p><p>每个数可以在子集中（选）</p><p>也可以不在子集中（不选）</p><p>叶子是答案</p><p>回溯三问：</p><ol><li>当前操作？枚举第 i 个数选&#x2F;不选</li><li>子问题？从下标 &gt;&#x3D; i 的数字中构造子集</li><li>下一个子问题？从下标 &gt;&#x3D; i + 1 的数字中构造子集</li></ol><p>dfs(i) -&gt; dfs(i + 1)</p><p>站在答案角度<br><img src="https://ammzz-1309932079.cos.ap-nanjing.myqcloud.com/typora_images202312011046431.png"></p><p>枚举第一个数选谁</p><p>枚举第二个数选谁……</p><p> 每个节点都是答案</p><p><strong>注意：</strong></p><p><strong>[1, 2]和[2, 1]是重复的子集</strong></p><p><strong>为了避免重复，下一个数应大于当前选择的数</strong></p><p>回溯三问：</p><ol><li>当前操作？枚举一个下标 j &gt;&#x3D; i 的数字，加入path</li><li>子问题？从下标 &gt;&#x3D; i 的数字中构造子集</li><li>下一个子问题？从下标 &gt;&#x3D; j + 1 的数字中构造子集</li></ol><p>dfs(i) -&gt; dfs(i + 1) &#x2F; dfs(i + 2) &#x2F; dfs(i + 3)</p><hr><p>Python代码：</p><p>从输入角度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从答案角度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            ans.append(path.copy())</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line"></span><br><span class="line">                path.append(nums[j])</span><br><span class="line">                dfs(j + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
